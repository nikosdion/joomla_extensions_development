<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright © 2022 Nikolaos Dionysopoulos

Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free
Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with
no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included
in the section entitled "GNU Free Documentation License".
-->
<chapter version="5.1" xml:id="plg" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xila="http://www.w3.org/2001/XInclude/local-attributes"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:trans="http://docbook.org/ns/transclusion"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Plugins</title>

  <para>Plugins are the fundamental building blocks of Joomla!. They let us
  execute code when something interesting happens. Unsurprisingly, plugins are
  extremely powerful and the cornerstone of implementing complex features
  which alter or add features in Joomla without having to modify core files
  (“hack core”) as is usual in other CMS. This lets us have very powerful,
  <emphasis>easily maintainable</emphasis>, sites.</para>

  <section xml:id="plg-forms">
    <title>The many forms of a Joomla plugin</title>

    <para>Joomla plugins have been around for a very long time. In fact,
    they've been around since before Joomla forked off Mambo in August 2005.
    They were called ‘mambots’ back then. Having such a fundamental feature
    for over two decades understandably means that there are many forms of
    plugins possible.</para>

    <section xml:id="plg-forms-legacy">
      <title>Legacy (Joomla 1.x to 3.x)</title>

      <para>It might come to you as a surprise, but the original way plugins
      were implemented in Joomla 1.0 back in 2005 is still supported in Joomla
      4. This support will be removed in Joomla 6, scheduled for release in
      2025, two decades after it first appeared. Sure, there have been
      refinements but the core concept still applies.</para>

      <important>
        <para>Even though Joomla uses this form of plugin for most of its core
        plugins in Joomla 4 (and possibly Joomla 5), this is a form of plugin
        which has been deprecated and will most likely go away in Joomla
        6.</para>

        <para>This form of plugin is only recommended if you are writing a
        version of your software which is meant to run on both Joomla 3 and
        Joomla 4 / 5, to facilitate people trying to migrate their sites over
        to a newer Joomla version.</para>

        <para>If you are writing software native to Joomla 4 and beyond you
        should use the <link linkend="plg-forms-j4-subscriberinterface">Joomla
        4 with SubscriberInterface</link> form of plugins explained further
        below.</para>

        <para>The only exception to this rule are, at the time of this
        writing, plugins in the editors-xtd folder because they are not real,
        pure Joomla plugins. Their class is instantiated directly by Joomla
        and the <methodname>onDisplay</methodname> method called
        directly.</para>
      </important>

      <para>Legacy plugins consist of a single class which is named
      PlgTypeName where Type is the plugin type a.k.a. folder (e.g. system,
      user, console, …) and Name is the name of the plugin. For example, we
      could have PlgSystemExample for a system plugin named
      <code>example</code> and which lives in
      <filename>plugins/system/example/example.php</filename>. The class
      always extends from <classname>\Joomla\CMS\Plugin\CMSPlugin</classname>
      or one of its sub-classes typically defined in a component (e.g. finder
      plugins extend from
      <classname>\Joomla\Component\Finder\Administrator\Indexer\Adapter</classname>
      which extends from
      <classname>\Joomla\CMS\Plugin\CMSPlugin</classname>).</para>

      <para>Any <emphasis role="bold">public</emphasis> method whose name
      starts with <code>on</code> is registered as an event listener.
      Therefore a method called <methodname>onFooBar</methodname> is
      registered as a legacy plugin event listener for an event called
      <code>onFooBar</code>.</para>

      <para>There's a small caveat when it comes to Joomla 4 and 5. If the
      method accepts only one parameter which is either named
      <code>$event</code> OR is type-hinted as a class implementing
      <interfacename>\Joomla\Event\EventInterface</interfacename> then the
      method is registered as an event listener, a new type of listener. See
      <link linkend="plg-forms-j4-listener-types">Legacy vs Event Listener
      methods</link>. This is a deliberate design choice which lets you write
      plugins which can simultaneously handle legacy events when running under
      Joomla 3 and modern events when running under Joomla 4 and 5. This lets
      you provide a version of your plugin which acts as a “bridge” for people
      migrating from Joomla 3 to 4 and 5: the same plugin can run on both
      versions of Joomla without breaking the site.</para>
    </section>

    <section xml:id="plg-forms-j4-classic">
      <title>Joomla 4 classic</title>

      <para>As noted earlier, Joomla 4 introduced <link
      linkend="concepts-container">Dependency Injection and service
      providers</link> for all extensions, of course including plugins. It
      should come as no surprise then that the second plugin variant we get is
      similar to the <link linkend="plg-forms-legacy">legacy plugins</link>
      but with namespaces and service providers.</para>

      <para>The first difference you will notice is that the XML manifest goes
      from this:</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;extension type="plugin" group="system" method="upgrade"&gt;
    &lt;name&gt;plg_system_example&lt;/name&gt;
    &lt;author&gt;D.Veloper&lt;/author&gt;
    &lt;creationDate&gt;2022-10&lt;/creationDate&gt;
    &lt;copyright&gt;(C) 2022 Acme Inc&lt;/copyright&gt;
    &lt;license&gt;GNU General Public License version 2 or later; see LICENSE.txt&lt;/license&gt;
    &lt;authorEmail&gt;d.veloper@acme.com&lt;/authorEmail&gt;
    &lt;authorUrl&gt;www.acme.com&lt;/authorUrl&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;description&gt;PLG_SYSTEM_EXAMPLE_XML_DESCRIPTION&lt;/description&gt;
    &lt;files&gt;
        <emphasis role="bold">&lt;filename plugin="example"&gt;example.php&lt;/filename&gt;</emphasis>
    &lt;/files&gt;
    &lt;languages&gt;
        &lt;language tag="en-GB"&gt;language/en-GB/plg_system_example.ini&lt;/language&gt;
        &lt;language tag="en-GB"&gt;language/en-GB/plg_system_example.sys.ini&lt;/language&gt;
    &lt;/languages&gt;
&lt;/extension&gt;
            </programlisting>

      <para>to this:</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;extension type="plugin" group="system" method="upgrade"&gt;
    &lt;name&gt;plg_system_example&lt;/name&gt;
    &lt;author&gt;D.Veloper&lt;/author&gt;
    &lt;creationDate&gt;2022-10&lt;/creationDate&gt;
    &lt;copyright&gt;(C) 2022 Acme Inc&lt;/copyright&gt;
    &lt;license&gt;GNU General Public License version 2 or later; see LICENSE.txt&lt;/license&gt;
    &lt;authorEmail&gt;d.veloper@acme.com&lt;/authorEmail&gt;
    &lt;authorUrl&gt;www.acme.com&lt;/authorUrl&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;description&gt;PLG_SYSTEM_EXAMPLE_XML_DESCRIPTION&lt;/description&gt;
    <emphasis role="bold">&lt;namespace path="src"&gt;Acme\Plugin\System\Example&lt;/namespace&gt;</emphasis>
    &lt;files&gt;
        <emphasis role="bold">&lt;folder&gt;services&lt;/folder&gt;</emphasis>
        <emphasis role="bold">&lt;folder plugin="example"&gt;src&lt;/folder&gt;</emphasis>
    &lt;/files&gt;
    &lt;languages&gt;
        &lt;language tag="en-GB"&gt;language/en-GB/plg_system_example.ini&lt;/language&gt;
        &lt;language tag="en-GB"&gt;language/en-GB/plg_system_example.sys.ini&lt;/language&gt;
    &lt;/languages&gt;
&lt;/extension&gt;
            </programlisting>

      <para>The affected lines are in bold type.</para>

      <para>First of all, we have a <tag>&lt;namespace&gt;</tag> tag to
      declare our namespace. The namespace follows the convention
      <code><replaceable>MyCompany</replaceable>\Plugin\Type\<replaceable>Name</replaceable></code>
      where MyCompany is the vendor namespace prefix, Type is the plugin type
      a.k.a. folder (e.g. system, user, console, …) and Name is the name of
      the plugin. TheType must be written as Uppercasefirst i.e. the first
      letter is uppercase and all others are lowercase.</para>

      <para>The second obvious change is that instead of a plugin file we have
      two folders, <filename>services</filename> and
      <filename>src</filename>.</para>

      <para>The <filename>services</filename> folder contains a single file,
      <filename>provider.php</filename>. It's very similar to <link
      linkend="com-services">a component's service provider
      file</link>:</para>

      <programlisting language="php">&lt;?php
defined('_JEXEC') || die;

use Joomla\CMS\Extension\PluginInterface;
use Joomla\CMS\Factory;
use Joomla\CMS\Plugin\PluginHelper;
use Joomla\DI\Container;
use Joomla\DI\ServiceProviderInterface;
use Joomla\Event\DispatcherInterface;
use Acme\Plugin\System\Example\Extension\Example;

return new class implements ServiceProviderInterface {
    public function register(Container $container)
    {
        $container-&gt;set(
            PluginInterface::class,
            function (Container $container)
            {
                $config  = (array)PluginHelper::getPlugin('system', 'example');
                $subject = $container-&gt;get(DispatcherInterface::class);

                $app = Factory::getApplication();

                /** @var \Joomla\CMS\Plugin\CMSPlugin $plugin */
                $plugin = new Example($subject, $config);
                $plugin-&gt;setApplication($app);

                return $plugin;
            }
        );
    }
};</programlisting>

      <para>The important thing to note here is that the service provider is
      responsible for registering a
      <interfacename>Joomla\CMS\Extension\PluginInterface</interfacename>
      service which returns an object instance of our plugin class.</para>

      <tip>
        <para>Your plugin class can also implement the
        <interfacename>\Joomla\CMS\Extension\BootableExtensionInterface</interfacename>
        interface. If it does, its <methodname>boot</methodname> method will
        be called when Joomla loads your plugin, before any event is executed,
        and gives you access to the plugin's Dependency Injection container.
        While you shouldn't try to execute any significant amount of code at
        this point (Joomla has not finished booting up yet!) and you shouldn't
        use the DI container directly to pull resources (the service provider
        is meant to push them to the plugin instead) it may come in handy for
        these, uh, <emphasis>forbidden</emphasis> purposes.</para>

        <para>Here's an example. There are <emphasis>some</emphasis> services
        which have a lengthy initialisation — for example, a foreign currency
        exchange service will need to periodically pull the currency exchange
        rates from a central bank's web site. Ideally, you'd want to move
        their initialisation outside the constructor and into a different
        method you need to call before doing something useful with your
        service. However, you may also run into chicken-and-egg situations
        trying to do that. If the server doesn't support cURL the service
        might throw an exception. I'd like to catch it so I can
        <emphasis>not</emphasis> offer this feature with unsatisfied server
        dependencies. But if I do that in the service provider I am also very
        likely trying to make a web request to the central bank's website to
        get the currency exchange rate at an inopportune moment where the
        application needs to finish loading as fast as possible.</para>

        <para>While there are clever ways to work around that, you may find it
        far easier to get access to the container in the
        <methodname>boot</methodname> method, store a reference to the
        container in a private property of your plugin and pull an instance of
        your custom forex service when you need it. If it throws an exception
        you can implement your “this isn't possible on this server” logic. By
        instantiating your service through the provider only when needed you
        solved your chicken-and-egg problem.</para>

        <para>A cleaner solution would of course be trying to check the server
        dependencies on service instantiation and set a flag in the service.
        When the service consumer (your plugin) tries to use the service you
        could throw an exception. This is an obvious solution in this simple
        problem. For more complex problems there might not be an equally
        obvious solution.</para>

        <para>As I always say to aspiring developers, your goal is to deliver
        something useful and maintainable in a finite period of time. If it
        means writing something a CS professor would give a disapproving
        frown, so be it. You can revisit that implementation later, when you
        have time to burn. As Steve Jobs succinctly put it, “<link
        xlink:href="https://leaderforgood.com/real-artists-ship/">real artists
        ship</link>”.</para>
      </tip>

      <para>The plugin class, as with legacy plugins, extends from
      <classname>\Joomla\CMS\Plugin\CMSPlugin</classname> and works the same
      as <link linkend="plg-forms-legacy">a Legacy plugin's</link>
      class.</para>

      <para>You will not see any plugins of this type in the core and they are
      pretty rare in the wild, mostly from software — like older versions of
      mine — which started the conversion process to Joomla 4 before Joomla 4
      was finished and before the modern event system was mature enough for
      general use.</para>

      <para>Practically speaking, the only use case for this type of plugin is
      if you still have plugin events which pass around scalar variables
      <emphasis>by reference</emphasis>. For example, something like
      this:</para>

      <programlisting language="php">public function onMyCustomEvent(string $foo, array &amp;$bar);</programlisting>

      <para>The $bar variable is a scalar (array) passed by reference. It can
      be modified by the plugin event handler. This will not be possible using
      modern events.</para>

      <para>If you want a clean solution you need to make changes in the code
      which calls this plugin event. Instead of passing around an array you'd
      have to pass a <classname>\Joomla\CMS\Object\CMSObject</classname> or
      <classname>\Joomla\Registry\Registry</classname> object created from the
      contents of the array. Your modern event handler can modify that object
      (objects are always passed by reference in all versions of PHP supported
      by Joomla 4 and beyond). Then your consumer code could convert back from
      an object to an array.</para>

      <para>The clean solution is admittedly more convoluted than you might
      expect and requires changes in the consumer which might not be possible
      if it's not code under your control. If you do not feel confident
      implementing the cleaner solution, or if it's just not possible because
      third party code is using your events, you can create a Joomla 4 classic
      plugin with a legacy plugin event handler for your plugin event which
      won't give you a hard time with scalar variables passed by reference.
      It's not the best coding practice but it does take a while —and several
      refactoring passes— to migrate to a cleaner architecture. Even more so
      considering that Joomla 3 and these coding practice had been around for
      nearly a decade before Joomla 4 was released.</para>
    </section>

    <section xml:id="plg-forms-j4-subscriberinterface">
      <title>Joomla 4 with SubscriberInterface</title>

      <para>You might remember from an earlier chapter talking about <link
      linkend="com-controllers-basic-services">the basic services in a
      component's service provider</link> that you can trigger plugins using
      modern events like so:</para>

      <programlisting language="php">$event = \Joomla\CMS\Event\GenericEvent::create('onSomething', [$param1, $param2]);
$this-&gt;getDispatcher()-&gt;dispatch($event-&gt;getName(), $event);
$results = $event-&gt;getArgument('result', []);</programlisting>

      <para>It follows reason that Joomla 4 offers a way to write plugins
      which only deal with these modern events. These events are faster and
      have many more tricks up their sleeves than the ‘dumb’ callback model
      implemented in Joomla 1.x, 2.x and 3.x.</para>

      <para>Plugins of this type are just like <link
      linkend="plg-forms-j4-classic">Joomla 4 classic plugins</link> with a
      twist. The plugin class implements the
      <interfacename>\Joomla\Event\SubscriberInterface</interfacename> and you
      set the protected property <code>$this-&gt;allowLegacyListeners =
      false;</code>. This changes the way Joomla registers event
      handlers.</para>

      <para>Joomla will NOT use reflection to find public methods whose name
      starts with <code>on</code>. It will instead call the public static
      method <methodname>getSubscribedEvents</methodname> which is defined in
      the interface and implemented in your plugin class. This returns an
      array mapping event names to public methods of your plugin. Not having
      to go through reflection saves <emphasis>a lot</emphasis> of time on
      every page load of the site. Moreover, events are self-contained objects
      being passed around which reduces the overhead of calling each event
      handler. These add up with the dozens to hundreds of plugins and event
      handlers running on a typical Joomla site, saving several dozens to a
      few hundreds of milliseconds of page load time. This is a significant
      performance improvement for the site. <emphasis role="bold">This is why
      I've been telling people since 2017, that modern events make Joomla 4
      and later versions faster</emphasis>.</para>

      <para>The implementation of the getSubscribedEvents method is pretty
      straightforward:</para>

      <programlisting language="php">public static function getSubscribedEvents(): array
{
    return [
        'onSomething'     =&gt; 'doSomething',
        'onSomethingElse' =&gt; ['doSomething', \Joomla\Event\Priority::HIGH],
    ];
}</programlisting>

      <para>The keys of the array are the event names. The values are the
      names of the methods which handle each event.</para>

      <para>But, wait a minute! That second item has an array value. What is
      that? Well, that's one of the benefits of using SubscriberInterface: you
      can tell Joomla about the priority you want for your event handler,
      meaning that the order plugins execute is not dictated only by their
      user-defined ordering in the backend of the site but also by the
      programmer's preferred priority.</para>

      <para>By default, all event handlers are attached with Normal priority.
      They are then executed in the order they were attached, i.e. how the
      plugins were ordered in the backend Plugins management page of the site.
      This is the only option you get with legacy and classic plugins.</para>

      <para>Plugins implementing the SubscriberInterface can optionally set a
      priority for each event handler. This is an integer. The higher the
      integer is, the earlier your event handler executes. Joomla first
      executes all event handlers with the highest priority number in the
      order they were attached. Then moves to the event handlers with the
      second highest priority number in the order they were attached and so
      on.</para>

      <para>If you set your priority to high, as I did above, your event
      handler will be one of the first (if not the absolute first) to be
      executed. If, conversely, you set it to
      <code>\Joomla\Event\Priority::MIN</code> or even
      <code>PHP_INT_MIN</code> your event handler will be one of the last (if
      not the absolute last) to be executed. In the few cases where this is
      truly needed you no longer have to tell your users to reorder plugins
      for your plugin to work correctly and predictably; you can just set the
      priority.</para>

      <caution>
        <para><emphasis role="bold">With great power comes great
        responsibility</emphasis>. Do NOT set the priority of your event
        handlers unless there is an absolute need to do so.</para>

        <para>For example, a security plugin will need to guarantee that its
        plugin events execute first to avoid other plugins' security
        vulnerabilities being triggered by malicious requests. Full page HTML
        source code search &amp; replace plugins will need to have their
        onAfterRender handler run as the very last to be able to replace HTML
        text right before it's potentially compressed and returned to the
        browser.</para>

        <para>The vast majority of plugins should NOT set a priority. By
        setting a priority you make it very hard if not impossible for the
        user to change the execution order of your plugin which might be
        necessary to work around issues on their site. <emphasis
        role="bold">DO NOT TAKE AWAY THE USER'S AGENCY UNLESS THERE IS AN VERY
        WELL JUSTIFIED AND DOCUMENTED REASON</emphasis>.</para>
      </caution>

      <para>Moreover, you should keep in mind that all methods handling events
      only accept one argument (by value, not reference!), an event object
      which implements the
      <interfacename>\Joomla\Event\EventInterface</interfacename> interface.
      We will talk about this in <link
      linkend="plg-forms-j4-listener-types">the next section on listener
      types</link>.</para>
    </section>

    <section xml:id="plg-forms-j4-listener-types">
      <title>Legacy vs Event Listener methods</title>

      <para>As we have already alluded to in the previous sections, there are
      two types of plugin event listeners.</para>

      <bridgehead>Legacy plugin event listeners</bridgehead>

      <para>Legacy plugin event listeners are nothing more than glorified
      callbacks. They are plain old methods which accept a number of
      parameters and possibly<footnote>
          <para>Actually, they always have to return a value. It just so
          happens that the return value of methods typehinted to return void
          is NULL in PHP. At some point, in newer PHP versions, this will
          start throwing an error which is another reason legacy listeners
          will have to eventually go away.</para>
        </footnote> return a value. For example, we could have something like
      this:</para>

      <programlisting language="php">public onSomething(string $foo, array $bar): array</programlisting>

      <para>This simplicity is simultaneously the strength and the Achille's
      heel of legacy plugin event handlers.</para>

      <itemizedlist>
        <listitem>
          <para>Having an arbitrary number of parameters makes it really hard
          to know what is the <emphasis>canonical</emphasis> parameters list
          when you are calling a plugin event and when you are implementing a
          handler for it.</para>
        </listitem>

        <listitem>
          <para>It's impossible to add new parameters, even optional ones,
          without a breaking change. If different handlers have a different
          number of parameters (or, worse, parameters order!) they expect you
          might get PHP warning or errors.</para>
        </listitem>

        <listitem>
          <para>Neither the parameters nor the return values can be
          type-hinted. This makes it perfectly possible for a developer, core
          or third party, to pass the wrong data type to an event's argument
          e.g. an object where an array is expected. It also makes for
          inconsistent return values which need to be normalised and validated
          in consumer code, i.e. every time an event is called.</para>
        </listitem>

        <listitem>
          <para>The aforementioned problems can result in bugs which are
          really hard to address. For example, a third party extension may
          cause a core or third party plugin to fail with a PHP error on PHP 8
          by passing the wrong data type to it. Conversely, a third party
          plugin may cause core or third party components or modules to fail
          by returning an unexpected data type. Identifying who messed up is
          hard. Explaining to a client that it's not your code at fault but a
          third party plugin may be really hard, especially if that third
          party plugin works fine in the <emphasis>very limited
          subset</emphasis> of use cases it was developed for and tested
          on.</para>
        </listitem>

        <listitem>
          <para>Running callbacks with an arbitrary number of arguments
          requires going through PHP's
          <function>call_user_func_array()</function> function which has more
          overhead than calling methods directly. This is only relevant on
          older PHP versions; the performance delta is nearly gone in PHP
          8.</para>
        </listitem>
      </itemizedlist>

      <para>The only thing this simple callback arrangement has going for it
      is that, well, it's very simple to implement in the code which calls the
      plugin events, the core code which runs the plugin event handlers and
      the code which consumes the results of plugin event handlers — though
      the latter is debatable.</para>

      <bridgehead>Modern event listeners</bridgehead>

      <para>Joomla 4 introduced a whole new concepts: <emphasis
      role="bold">events</emphasis>.</para>

      <para>Each event is its own object. It has arguments which can be
      anonymous or named, typically the former in generic events and the
      latter in <link linkend="plg-concrete-events">concrete events</link>.
      Events always have a named argument called <code>result</code> which
      lets the event handler not only return a result but also inspect what
      other results were returned by event handlers called before it (most
      concrete events have an <methodname>addResult</methodname> method to
      facilitate returning results). A concrete event class can implement type
      checks and validation of any (or all) of its arguments, including the
      results. It's no longer the Wild West.</para>

      <para>Event handlers have the option to stop the processing of an
      event's handlers by calling the event object's
      <methodname>stopPropagation</methodname> method; this is useful when you
      want to run a number of plugins until you get at least one result. Think
      about avatars displayed in a forum. You may have a number of plugins
      which can return an avatar image: Gravatar (if the user has an account
      there), using an image source from a user field, Facebook (if the user
      has linked an account), a locally installed social network component,
      and a fall-back to a generated fake avatar. The first avatar found will
      be used, the rest will be discarded. If the rest are going to be
      discarded, why even bother running the code to check if they exist?!
      Instead, each avatar plugin would work like this. It runs its code. If
      there is no avatar to be reported, return. If there is an avatar to be
      reported use <methodname>addResult</methodname> to return it and call
      the event's <methodname>stopPropagation</methodname> method to prevent
      the other avatar plugins from running for no reason and wasting the
      user's time and your server's resources. This is something you just
      cannot do with legacy event listeners.</para>

      <para>Also, as we mentioned earlier, modern event handlers can have
      prioritised event handlers with all the benefits we already
      mentioned.</para>

      <para>Modern event handlers are fairly simple:</para>

      <programlisting language="php">public function handleSomething(\Joomla\Event\Event $event): void</programlisting>

      <para>Note the type-hint to the <code>$event</code> argument. As written
      above, the method can be used to handle any event. In most cases you
      will need to use a concrete event class: either the concrete core event
      classes supplied in Joomla's <filename>libraries/src/Event</filename>
      directory and its subdirectories or a concrete event class provided by
      another Joomla extension.</para>

      <para>Getting the arguments to the event depends on the event class
      itself. For generic events you'd need to do something like:</para>

      <programlisting language="php">[$param1, $param2, $param3] = $event-&gt;getArguments();</programlisting>

      <para>That's because generic events do not have named arguments. This is
      the equivalent of having a legacy plugin event handler with the method
      signature:</para>

      <programlisting language="php">public function onSomething($param1, $param2, $param3);</programlisting>

      <para>With concrete events, it depends on the event. In most cases you'd
      do either of the following:</para>

      <programlisting language="php">// Named arguments without a getter method
$param1 = $event-&gt;getArgument('param1');
// Named arguments with getter methods
$param2 = $event-&gt;getParam1();</programlisting>

      <para>Any decent IDE will let you know if there is a getter in
      <code>$event</code> based on its type-hint. That's why it makes sense to
      type-hint your event handler methods correctly.</para>

      <para>The return type of a modern event handler is always void. You do
      NOT return values directly. Instead, you add them to the
      <code>result</code> argument which is always an array:</para>

      <programlisting language="php">$result = $this-&gt;getArgument('result') ?? [];
$result[] = $theResultIAmReturning;
$this-&gt;setArgument('result', $result);</programlisting>

      <para>Most concrete event classes implement the
      <interfacename>\Joomla\CMS\Event\Result\ResultAwareInterface</interfacename>
      which has the <methodname>addResult</methodname> method to return values
      more easily:</para>

      <programlisting language="php">$this-&gt;addResult($theResultIAmReturning);</programlisting>

      <para>Finally, remember that events can be mutable, immutable or
      selectively immutable. A mutable event allows its handlers to use
      <methodname>setArgument</methodname> freely, modifying all of its
      arguments.</para>

      <caution>
        <para>Even though <emphasis>most</emphasis> core events are currently
        mutable, this <emphasis>will</emphasis> change in Joomla 5 and Joomla
        6. Joomla is moving towards concrete event classes for all core
        events. These concrete classes will be selectively immutable: all of
        their arguments will be immutable except for the <code>result</code>
        argument; the latter only if it's an event which expects a result to
        be returned.</para>

        <para>Therefore you MUST NOT rely on core events' arguments being
        mutable at the moment. Treat them as immutable or you <emphasis>will
        suffer</emphasis> in the future!</para>
      </caution>

      <para>An immutable event does not allow any of its arguments to be set
      after it has been created. This does not mean that you cannot do
      anything with the arguments! Remember that argument values which are
      objects can be modified without needing to set the argument again. For
      example, this is a valid, working event handler:</para>

      <programlisting language="php">	public function handleTableAfterLoad(\Joomla\CMS\Event\Table\AfterLoadEvent $event): void
{
    if (!$event-&gt;getArgument('result')) return;

    /** @var \Joomla\CMS\Table\TableInterface $table */
    $table = $event-&gt;getArgument('subject');

    $table-&gt;modified_by = \Joomla\CMS\Factory::getApplication()
        -&gt;getIdentity()
        -&gt;id;
}</programlisting>

      <para>The <classname>\Joomla\CMS\Event\Table\AfterLoadEvent</classname>
      concrete event class is an <emphasis>immutable</emphasis> event.
      However, it has a <code>subject</code> argument which contains a Joomla
      Table object. All objects in PHP are passed by reference; any change we
      make to it will persist when we return from our method. That's why we
      can change its <code>modified_by</code> property without returning any
      value from our event handler and despite the event itself being
      immutable.</para>

      <para>Finally, we have selective immutable events. On the face of it,
      they are immutable events. However, they have setter methods for
      specific named arguments. Actually, the
      <classname>\Joomla\CMS\Event\Table\AfterLoadEvent</classname> is a
      selectively immutable event. It has setters for the <code>result</code>
      and <code>row</code> arguments. Every event implementing
      <interfacename>\Joomla\CMS\Event\Result\ResultAwareInterface</interfacename>
      is selectively immutable; there is always the
      <methodname>addResult</methodname> method to add to the results returned
      by the event.</para>

      <para>Handling events is a bit more involved than using simple callback
      methods like you used to in legacy plugins. If you feel utterly lost,
      <code>var_dump</code> the <code>$event</code> variable and
      <code>die();</code><footnote>
          <para>You can of course attach a PHP debugger and add a breakpoint
          to your event handler to better inspect what is going on. Even
          though this method is preferable I understand that not everyone
          knows how to do it. Plus, var_dump and die is easy and I use it too
          when I just want to get a quick idea of what's going on with a
          variable without having to temporarily disable my other breakpoints.
          All tools are useful when used appropriately.</para>
        </footnote>. You will get a lot of insight as to what the event does
      and which data does it carry.</para>
    </section>
  </section>

  <section xml:id="plg-namespaces">
    <title>Namespaces</title>

    <para>Before Joomla 4.0 all plugins were a single class which followed the
    naming convention
    <classname>Plg<replaceable>Folder</replaceable><replaceable>Name</replaceable></classname>
    where <code>Folder</code> is the plugin folder with its first letter
    capitalised (e.g. <code>System</code> for <code>system</code> plugins) and
    <code>Name</code> is the plugin's name with all of its letters lowercase
    except the first one which is capitalised (e.g. Example). Thus a plugin
    named <code>example</code> in the <code>system</code> folder would have
    the class name PlgSystemExample.</para>

    <para>In those earlier Joomla versions the file name of the plugin was
    also prescribed and could not change. The aforementioned plugin's class
    file would necessarily be
    <filename>plugins/system/example/example.php</filename>. The immediate
    result of that is that the file name and the class name are not the same
    which makes class autoloading for plugins a pain in the posterior.
    Therefore, we had no autoloading for plugins.</para>

    <para>While this is not a problem for trivial plugins, it can become a
    substantial issue for more complex plugins. As a developer you either had
    to create a supermassive class running into the several thousands of lines
    of code or you'd have to “invent” your own autoloader. Typically it would
    be the latter, with the plugin's constructor method using
    <code>\JLoader::register</code> or <code>\JLoader::registerPrefix</code>
    to register individual, arbitrarily named classes or a PSR-4 namespace
    used by the plugin. The former ran the risk of having same-named classes
    declared by multiple plugins with the site breaking. The latter ran the
    risk of having two or more plugins trying to use the same-named namespace,
    again breaking the site.</para>

    <para>Joomla 4.0 added <link
    linkend="concepts-namespaces">namespaces</link> support for plugins. All
    we have to do is declare a namespace, a root folder for it under our
    plugin and make sure that the folder and file names follow the <link
    xlink:href="https://www.php-fig.org/psr/psr-4/">PSR-4</link>
    standard.</para>

    <para>Your plugin's namespace prefix is declared in the XML manifest of
    the plugin using a new XML element under the
    <code>&lt;extension&gt;</code> root element:</para>

    <programlisting language="xml">&lt;namespace path="src"&gt;My\Namespace\Prefix&lt;/namespace&gt;</programlisting>

    <para>The <code>path</code> attribute tells Joomla which subdirectory of
    your extension holds the PSR-4 of your extension's PHP files. It is best
    practice to name it <filename>src</filename> but <emphasis>you don't have
    to</emphasis>. I always assume you are using
    <filename>src</filename>.</para>

    <para>The text inside the XML element, <code>My\Namespace\Prefix</code> in
    our example, is the namespace prefix you will be using. Each plugin can
    register its own namespace prefix without any restrictions. It is
    <emphasis>recommended</emphasis> to use the convention
    <code><replaceable>MyCompany</replaceable>\Plugin\<replaceable>Folder</replaceable>\<replaceable>Name</replaceable></code>
    where <code>MyCompany</code> is the vendor namspace prefix,
    <code>Folder</code> is the plugin folder with its first letter capitalised
    (e.g. <code>System</code> for <code>system</code> plugins) and
    <code>Name</code> is the plugin's name with all of its letters lowercase
    except the first one which is capitalised (e.g. Example). Thus a plugin
    made by Acme Inc named <code>example</code> in the <code>system</code>
    folder would have the namespace <code>Acme\Plugin\System\Example</code>.
    Using this convention ensures that there will be no overlap in namespaces
    of different plugins since you cannot have two different plugins with the
    same name and plugin type.</para>

    <note>
      <para>Unlike components, this is the entire namespace for your plugin.
      You do NOT get a different namespace per Joomla application (frontend,
      backend or API).</para>
    </note>

    <para>Your plugin's class does not have to follow any specific naming
    convention or be placed in a specific sub-namespace of the plugin's
    namespace. This is determined in the plugin's <link
    linkend="plg-services">Service Provider</link>. It does have to extend
    from <classname>\Joomla\CMS\Plugin\CMSPlugin</classname> or one of its
    descendant classes.</para>

    <para>It is <emphasis>customary</emphasis> to name it
    <code>Extension</code>, <code>Plugin</code>, or after the name of your
    plugin (e.g. <code>Example</code>) and place it in the
    <code>Extension</code> sub-namespace of your plugin. For example, our
    aforementioned example system plugin would customarily have its main
    plugin class be
    <classname>Acme\Plugin\System\Example\Extension\Example</classname>.</para>

    <para>Any other classes you are shipping with and using in your plugin
    just follow the PSR-4 class naming standard.</para>

    <para>The best part? Joomla registers namespaces when it boots. Even if
    your plugin is not yet loaded (but <emphasis>is</emphasis> enabled!) you
    have access to its classes using Joomla's PSR-4 autoloader. This is a
    typically much faster way to find out if a plugin is loaded or not instead
    of going through
    <methodname>\Joomla\CMS\Plugin\PluginHelper::isEnabled</methodname>. For
    example:</para>

    <programlisting language="php">// The old way
$hasSystemExample = <methodname>\Joomla\CMS\Plugin\PluginHelper::isEnabled</methodname>('system', 'example');
// The new way
$hasSystemExample = class_exists(\Acme\Plugin\System\Example\Extension\Example::class, true);</programlisting>

    <para>This does NOT mean that you should stop using
    <methodname>\Joomla\CMS\Plugin\PluginHelper::isEnabled</methodname>
    though. There are plenty of cases where you know the type and name of a
    plugin but do not know how it has named its plugin class. In this case go
    through the slower, old way; it's safer than making arbitrary assumptions.
    Use the new way only for your own plugins since you are in full control of
    their classes's naming.</para>
  </section>

  <section xml:id="plg-services">
    <title>Service Provider</title>

    <para>As discussed in a previous section, the service provider file is
    mandatory for Joomla 4 native plugins, lives in the plugin's
    <filename>services</filename> folder and always named
    <filename>provider.php</filename>.</para>

    <para>The absolutely minimal minimal service provider file looks like the
    following:</para>

    <programlisting language="php">&lt;?php
defined('_JEXEC') || die;

use Joomla\CMS\Extension\PluginInterface;
use Joomla\CMS\Plugin\PluginHelper;
use Joomla\DI\Container;
use Joomla\DI\ServiceProviderInterface;
use Joomla\Event\DispatcherInterface;
use Acme\Plugin\System\Example\Extension\Example;

return new class implements ServiceProviderInterface
{
    /**
     * Registers the service provider with a DI container.
     *
     * @param   Container  $container  The DI container.
     *
     * @return  void
     *
     * @since   4.2.0
     */
    public function register(Container $container)
    {
        $container-&gt;set(
            PluginInterface::class,
            function (Container $container) {
                $config  = (array) PluginHelper::getPlugin('system', 'example');
                $subject = $container-&gt;get(DispatcherInterface::class);

                return new Example($subject, $config);
            }
        );
    }
};</programlisting>

    <para>As you can see the service provider returns an <link
    xlink:href="https://www.php.net/manual/en/language.oop5.anonymous.php">anonymous
    PHP class</link> which implements the
    <code>Joomla\DI\ServiceProviderInterface</code>. That's the standard way
    to extend Joomla's DIC. Joomla creates a <emphasis>copy</emphasis> of its
    DIC and uses it as our plugin's own DIC. The service providers we set up
    in our plugin stay with our plugin, they do not leak out to the global
    application scope (the global Joomla DIC you get through the
    <code>Joomla\CMS\Factory::getContainer()</code> static method).</para>

    <para>The code in the anonymous function does the bare minimum of setting
    up a plugin. If you need to register custom service providers for your
    plugin do it before this code.</para>

    <para>The return line creates the plugin object from the plugin's class.
    If you need to push services into your plugin's object instance you will
    have to replace that line with something like this:</para>

    <programlisting language="php">$plugin = Example($subject, $config);
$plugin-&gt;setMyCustomService($container-&gt;get(MyCustomService::class));

return $plugin;</programlisting>
  </section>

  <section xml:id="plg-extension">
    <title>Extension class (plugin)</title>

    <para>The plugin class has not changed in any significant manner apart
    from the fact that it can now be namespaced and have any name you please
    as we learned in the previous two sections. It still extends from
    <classname>\Joomla\CMS\Plugin\CMSPlugin</classname> or one of its
    subclasses.</para>

    <para>The biggest difference is that since Joomla 4.0 <link
    linkend="plg-forms-j4-listener-types">you can implement the
    <classname>\Joomla\Event\SubscriberInterface</classname></link> in your
    plugin class to handle modern events instead of registering plugin event
    callbacks, as we already discussed.</para>

    <para>The other big change starting with Joomla 4.2 is that you no longer
    need to declare an <code>$app</code> property to magically get access to
    the Joomla application object or a <code>$db</code> property to magically
    get access to the database driver object. Instead, you need to set up
    these features through your service provider.</para>

    <note>
      <para>While you can still use the two properties, doing so will trigger
      a PHP deprecated notice. Unfortunately, if you want to support earlier
      Joomla versions (e.g. 3.x, 4.0 and 4.1) this is all you can do.</para>
    </note>

    <bridgehead>Accessing the Joomla application object</bridgehead>

    <para>Modify your provider's return line to read something like the
    following:</para>

    <programlisting language="php">// Create the plugin
$plugin = Example($subject, $config);
// Push the application object
$plugin-&gt;setApplication(\Joomla\CMS\Factory::getApplication());

return $plugin;</programlisting>

    <para>In your plugin's code you can now get the Joomla application object
    by doing</para>

    <programlisting language="php">$app = $this-&gt;getApplication();</programlisting>

    <bridgehead>Accessing the Joomla database driver object</bridgehead>

    <para>Accessing the Joomla database driver object is
    <emphasis>slightly</emphasis> more complicated.</para>

    <para>First of all, your plugin class must have the
    <classname>\Joomla\Database\DatabaseAwareInterface</classname> in its
    implements list and use the
    <classname>\Joomla\Database\DatabaseAwareTrait</classname>. For
    example:</para>

    <programlisting language="php">class Example extends \Joomla\CMS\Plugin\CMSPlugin
implements \Joomla\Database\DatabaseAwareInterface
{
    use \Joomla\Database\DatabaseAwareTrait;

    // The rest of the plugin class goes here.
}</programlisting>

    <para>Your service provider must have the following line before the
    <code>return $plugin;</code> line:</para>

    <programlisting language="php">$plugin-&gt;setDatabase($container-&gt;get('DatabaseDriver'));</programlisting>

    <para>Inside your plugin's class you can now access the database driver
    object like this:</para>

    <programlisting language="php">$db = $this-&gt;getDatabase();</programlisting>
  </section>

  <section xml:id="plg-lang">
    <title>Language files</title>

    <para>The Joomla language files have not really changed much since Joomla
    1.0. Joomla is using the <link
    xlink:href="https://en.wikipedia.org/wiki/INI_file">INI format</link> with
    a few twists:</para>

    <itemizedlist>
      <listitem>
        <para>The keys must always be in UPPERCASE. You cannot have keys in
        lowercase or MixedCase.</para>
      </listitem>

      <listitem>
        <para>The values to the right of the equals sign must be enclosed in
        double quotes (<code>"</code>).</para>
      </listitem>

      <listitem>
        <para>If you want to use double quotes inside your values you need to
        escape them as <code>\"</code>.</para>
      </listitem>

      <listitem>
        <para>Some language strings are used in JavaScript code using a legacy
        method. They do not support escaped double quotes. Use single quotes
        (<code>'</code>) instead, even for HTML attributes (yes, HTML allows
        you to do things like <code>&lt;a
        href='https://www.example.com'&gt;example&lt;/a&gt;</code> even though
        attribute values <emphasis>should</emphasis> use double quotes for
        compatibility with XHTML). If you want to put quotes around
        human-readable text you can also use calligraphic quotes: <code>“ ” ‘
        ’</code> and so on.</para>
      </listitem>

      <listitem>
        <para>You can comment a line by putting a semicolon (<code>;</code>)
        as its first character. Do not put semicolons at the end of strings,
        they might be parsed as part of the value.</para>
      </listitem>
    </itemizedlist>

    <bridgehead>No more language tags in filenames</bridgehead>

    <para>There is a pretty big change for language file
    <emphasis>naming</emphasis> in Joomla 4 and beyond: <emphasis
    role="bold">you must not use the language prefix</emphasis>.</para>

    <para>In Joomla 1.5 to 3.10 inclusive language files were named like
    <filename>en-GB.plg_system_example.ini</filename> (British English),
    <filename>de-DE.plg_system_example.ini</filename> (German, Germany) and
    <filename>de-AT.plg_system_example.ini</filename> (German,
    Austria).</para>

    <para>However, that naming was highly redundant as starting with Joomla
    1.6 in 2010 the language files had to be placed in a folder whose name was
    the language tag itself! Inside a language folder you'd have the relative
    filepaths <filename>en-GB/en-GB.plg_system_example.ini</filename>,
    <filename>de-DE/de-DE.plg_system_example.ini</filename> and
    <filename>de-AT/de-AT.plg_system_example.ini</filename>. Having the same
    language tag appear twice in a pathname didn't make sense. Therefore in
    Joomla 4 and beyond we no longer use the language tag prefix!</para>

    <para>The files are now simply named similar to
    <filename>plg_system_example.ini</filename>. The language of the file is
    inferred from the folder name it's in. For example, the filepath
    <filename>en-GB/plg_system_example.ini</filename> obviously refers to
    British English.</para>

    <bridgehead>Plugin language files</bridgehead>

    <para>A plugin has multiple different language files. The base name of all
    files is the name of the Joomla component extension, e.g.
    <code>plg_system_example</code>(the two latter parts separated by
    underscores is the plugin type a.k.a. folder and the plugin name, in all
    lowercase):</para>

    <itemizedlist>
      <listitem>
        <para><filename>plg_system_example.sys.ini</filename> — System
        language file. Required. It only needs the two language keys for the
        plugin name and its XML manifest file's description. Used during
        installation.</para>
      </listitem>

      <listitem>
        <para><filename>plg_system_example.ini</filename> — Language file.
        Required. Has the language keys for all of the plugin's options. Also
        needs the two language keys for the plugin name and its XML manifest
        file's description. It can also contain any language strings you are
        using during the execution of your plugin.</para>
      </listitem>
    </itemizedlist>

    <para>Plugin language files are placed in the <emphasis
    role="bold">administrator</emphasis> application's
    <filename>language</filename> subdirectory — even for plugins which ONLY
    run in the frontend of the site! For example, the language files for
    British English are placed in
    <filename>administrator/language/en-GB</filename>. Moreover, Joomla will
    fall back to the language subdirectory under your plugin. For example, the
    language files for British English are also sought for in
    <filename>plugins/system/example/language/en-GB</filename>. If files exist
    in both locations then <emphasis>only</emphasis> the one in the
    application's directory will be loaded.</para>

    <bridgehead>Language file autoloading</bridgehead>

    <para>Unlike previous versions of Joomla, you do NOT have to load your
    language files manually. Joomla loads your plugin's language files
    automatically.</para>

    <para>All you need to do is set the protected property
    <property>autoloadLanguage</property> to <code>true</code> in your
    constructor:</para>

    <programlisting language="php">public function __construct(&amp;$subject, $config = array())
{
    $this-&gt;autoloadLanguage = true;

    parent::__construct($subject, $config);
}</programlisting>

    <important>
      <para>The parent constructor method must be called AFTER setting the
      property. Otherwise your language files will not be loaded.</para>
    </important>

    <para>If you prefer to load the language files of your plugin only when
    they are absolutely needed you just need to call:</para>

    <programlisting language="php">$this-&gt;loadLanguage();</programlisting>

    <para>Since Joomla 3.3 (based on my recollection, +/- 1 minor version…)
    Joomla will load language files in this order:</para>

    <itemizedlist>
      <listitem>
        <para>(Only if Debug Language is disabled). The language file for the
        site's default language (<code>en-GB</code>, unless a third party
        extension has changed it).</para>
      </listitem>

      <listitem>
        <para>The currently active language's normative INI file (e.g.
        <code>plg_system_example.ini</code>) or legacy INI file (e.g.
        <code>en-GB.plg_system_example.ini</code>).</para>
      </listitem>
    </itemizedlist>

    <para>Joomla will first look in the <emphasis
    role="bold">administrator</emphasis> application's language folder i.e.
    <filename>administrator/language</filename> . This applied even if you are
    in the frontend of the site, the API application or the CLI
    application.</para>

    <para>If neither the current language's, nor the default language's files
    have been found Joomla will fall back to your plugin's
    <filename>language</filename> directory. That is to say, your plugin's
    language directory is a last resort and not guaranteed to be used!</para>

    <para>You may wonder: why does Joomla load both the default language
    (British English in most cases) <emphasis>and</emphasis> my current
    language (e.g. Canadian French) files? The reason is simple. All plugins
    are required to provide a complete language file for the default language
    which for Joomla is British English (<code>en-GB</code>). Translation to
    other languages are optional and often incomplete. Sometime around 2012 we
    decided that it makes far more sense to show an English, human-readable
    string to non-English speakers they can look up in the dictionary or their
    favorite translation tool than an incomprehensible language key like
    <code>PLG_SYSTEM_EXAMPLE_CONFIG_EARLY_PREP_ARRAY_LABEL</code>. Of course
    this makes it harder for translators. That's why the Debug Language
    feature was simultaneously introduced. When enabled, the default language
    is not enabled and untranslated strings are marked clearly in the
    output.</para>

    <bridgehead>Defining language files in your XML manifest</bridgehead>

    <para>Your XML manifest needs one set of <tag>&lt;languages&gt;</tag> tags
    under the <tag>&lt;extension&gt;</tag> root:</para>

    <programlisting language="xml">&lt;extension&gt;
&lt;!-- … --&gt;
&lt;languages folder="language"&gt;
    &lt;language tag="en-GB"&gt;en-GB/plg_system_example.ini&lt;/language&gt;
    &lt;language tag="en-GB"&gt;en-GB/plg_system_example.sys.ini&lt;/language&gt;
    &lt;language tag="de-DE"&gt;de-DE/plg_system_example.ini&lt;/language&gt;
    &lt;language tag="de-DE"&gt;de-DE/plg_system_example.sys.ini&lt;/language&gt;
&lt;/languages&gt;
&lt;!-- … --&gt;
&lt;/extension&gt;</programlisting>

    <para>This copies the files from the <filename>language/</filename> folder
    in your package to Joomla's admin language folder, e.g. the
    <filename>language/en-GB/plg_system_example.ini</filename> file in your
    package to
    <filename>administrator/language/en-GB/plg_system_example.ini</filename>
    file on your site.</para>

    <bridgehead>Language overrides</bridgehead>

    <para>Language overrides are loaded <emphasis>before</emphasis> any of
    your language files, at the initialisation of the CMSApplication object,
    namely when the Language object is constructed. They are stored in the
    file
    <filename>language/overrides/<replaceable>LANGUAGE_TAG</replaceable>.override.ini</filename>
    under the application's root (site root for the frontend,
    <filename>administrator</filename> for the backend,
    <filename>api</filename> for the API application) where
    <replaceable>LANGUAGE_TAG</replaceable> is the current language's tag,
    e.g. <code>en-GB</code> for British English.</para>

    <warning>
      <para>Overrides for the frontend and the backend of the site are
      different for plugins! Even though the plugin's language files are
      always stored in the backend (even if it runs in the frontend of the
      site), the overrides Joomla loads if the plugin is executing in the
      frontend of the site are those set for the site's frontend or marked as
      for both front- and backend.</para>

      <para>If you think about it, it makes sense. The frontend and backend of
      the site target different kinds of users. The public frontend may need a
      different worded message to address its target audience more
      effectively.</para>
    </warning>

    <para>The way it works is that your language file is loaded and then the
    <emphasis>overridden</emphasis> strings are replaced into the language
    file <emphasis>if and only if</emphasis> they are already defined in the
    language file.</para>

    <caution>
      <para>This means that the language overrides cannot be used for language
      keys not defined in your language files, unlike Joomla 3.</para>

      <para>Since this was a widely popular “trick” to allow your users to
      customise the display of your components you now have to take that
      explicitly into account. For example, given an item with an alias
      <code>foobar</code> you might be looking for the language string
      <code>PLG_SYSTEM_EXAMPLE_ITEM_OVERRIDE_FOOBAR_TITLE</code> to override
      the title field of your item for display in different languages. This
      worked in Joomla 3 but will NOT work in Joomla 4 or later.</para>

      <para>As noted in <link linkend="com-lang">the language section for
      components</link>, you can use custom language files to work around this
      problem.</para>
    </caution>
  </section>

  <section xml:id="plg-dont-break-joomla">
    <title>How NOT to break Joomla with your plugin</title>

    <para>Plugins are fundamental part of our sites. They can do a lot of
    useful things and extend Joomla in ways the core may have not been
    designed to. For this reason plugins have a lot of power over the entire
    Joomla application. A mistake in a plugin can bring down a site or cause
    unexpected and unresolvable issues in third party components, plugins and
    modules.</para>

    <para>The root cause of these problems is typically that the plugin author
    did test their plugin, but have only done so in the very narrow use case
    they expect their plugins to be used. This is called “<link
    xlink:href="https://en.wikipedia.org/wiki/Happy_path">happy path</link>
    testing” and is almost as bad as no testing at all. When the plugin is
    used in any other context — the CLI application, non-HTML output, in cases
    where the output format may not be determined until after the component
    for the page has finished executing — it might cause unintended
    consequences, i.e. the site will break. Even worse, clients will start
    blaming the innocent parties: Joomla itself and third party developers
    whose software is written the right way and works perfectly fine.</para>

    <para>To best demonstrate how easy it is to make grave mistakes with too
    little code let's see a plugin class which makes <emphasis
    role="bold">four</emphasis> major mistakes in six lines of code:</para>

    <programlisting language="php">class PlgSystemFoobar extends \Joomla\CMS\Plugin\CMSPlugin
{
    public function __construct(&amp;$subject, $config)
    {
        parent::__construct($subject, $config);

        if (\Joomla\CMS\Factory::getApplication()-&gt;isClient('administrator')) return;

        $document = \Joomla\CMS\Factory::getDocument();
        $document-&gt;addScript(\Joomla\CMS\Uri\Uri::root(true) . 'plugins/system/foobar/js/foobar.js');
    }
}</programlisting>

    <para>This looks like a deceptively simple system plugin. It adds a
    JavaScript file to every page load in the frontend. Right?</para>

    <para>Well, that is its intention but not what it actually does. It also
    breaks Joomla 4's CLI and API applications, it breaks pages with non-HTML
    output, it forbids components from using non-HTML output and tries to load
    the JavaScript file from the wrong place.</para>

    <bridgehead>Do not execute plugin logic in the plugin
    constructor</bridgehead>

    <para>Let's think about Joomla's lifetime. In broad terms, the request
    ends up getting handled by Joomla's <filename>index.php</filename> file.
    This spins up the Joomla! application, e.g.
    <code>\Joomla\CMS\Application\SiteApplication</code> for the frontend. The
    main entry point for the application object is the <code>doExecute</code>
    method. This method does a lot of initialisation before routing and
    dispatching the application, meaning that this initialisation takes place
    before Joomla has parsed SEF URLs or created a document object. In fact,
    Joomla will load all enabled <emphasis role="bold">system</emphasis>
    plugins before Joomla has figured out any basic facts about itself.</para>

    <para>The developer of this plugin put their business logic in the
    constructor of the plugin which is executed at this early stage of the
    Joomla application initialisation. While
    <methodname>isClient()</methodname> will work, the rest of the code which
    tries to get the document object will break the site.</para>

    <para>The plugin erroneously goes through the
    <methodname>\Joomla\CMS\Factory::getDocument()</methodname> method to get
    the document. This is deprecated in Joomla 4. You are supposed to use the
    <methodname>getDocument()</methodname> method of the application object.
    Had the developer done that they'd have seen that they are getting null
    because the document has not been created yet.</para>

    <para>In fact, all this code should be moved from the plugin object
    constructor to the <code>onAfterDispatch</code> method to work
    correctly.</para>

    <bridgehead>Do not go through the
    <classname>\Joomla\CMS\Factory</classname></bridgehead>

    <para>The second problem with this plugin is the exact reason why the
    Factory's <methodname>getDocument()</methodname> method is
    deprecated.</para>

    <para>Calling the factory's <methodname>getDocument()</methodname> method
    will forcibly create a document object which will then be used by the
    application object. The document object is created based on the
    information in the request. However, as you might recall, at this point
    Joomla has not yet parsed the SEF route! This would also be true if this
    code was moved in the <code>onAfterInitialise</code> event, the earliest
    system plugin event triggered by Joomla.</para>

    <para>Since the SEF URL has not been parsed Joomla cannot reliably know
    the type of document to use. Think for example about a URL like
    <uri>https://www.example.com/foobar.json</uri> which when gone through the
    SEF URL router will, among other things, set <uri>format=json</uri> in the
    request. This means that this request expects Joomla to create a
    <classname>\Joomla\CMS\Document\JsonDocument</classname> document
    object.</para>

    <para>However, since <uri>format=json</uri> has not been set yet, Joomla
    will assume <uri>format=html</uri> when you call
    <methodname>getDocument()</methodname>. Therefore, it will create a
    <classname>\Joomla\CMS\Document\HtmlDocument</classname> document object
    which will be used by the application object as well. This will of course
    break the component which is handling the request as it (correctly) expect
    a JSONDocument and it instead gets an HTMLDocument. I think we can all
    agree that the plugin's author is at fault for this mess.</para>

    <para>You should only ever call <emphasis role="bold">two
    methods</emphasis> of the <classname>\Joomla\CMS\Factory</classname> in
    Joomla 4:</para>

    <itemizedlist>
      <listitem>
        <para><methodname>getContainer()</methodname>. This returns Joomla's
        Dependency Injection container (DI Container, sometimes abbreviated as
        DIC). If possible, you should avoid using it directly, instead pushing
        dependencies through the service provider of your extension.</para>
      </listitem>

      <listitem>
        <para><methodname>getApplication()</methodname>. This returns the
        current Joomla application object handling the request. If possible,
        your extension should be passed the application object from its
        service provider instead of getting the object through the factory in
        your extension's code. The service provider will still have to go
        through the factory as there is not yet a single container resource
        which returns the currently active application (but this might change
        in Joomla 5.0 and will almost definitely change by Joomla 6.0).</para>
      </listitem>
    </itemizedlist>

    <para>To get the application's document you should do
    <code>\Joomla\CMS\Factory::getApplication()-&gt;getDocument();</code>.</para>

    <bridgehead>There is more to Joomla than HTML output</bridgehead>

    <para>This is an absurdly common mistake. Developers seem to assume that
    Joomla will only ever generate HTML output. This is an unreasonable
    assumption since Joomla 1.0 was released in 2005 — not to mention that it
    was not a reasonable assumption in Mambo, Joomla's predecessor, either.
    Joomla is perfectly capable of generating non-HTML output such as XML,
    JSON, RSS feeds, Atom feeds, raw binary output (e.g. images) and so on and
    so forth. If there was ever a question as to whether this is possible,
    changes made early in the Joomla 3.x releases introducing new core
    document and view classes should have driven that point home.</para>

    <para>The developer of this plugin made the
    <emphasis>unreasonable</emphasis> assumption that their
    <varname>$document</varname> will always contain an
    <classname>HTMLDocument</classname>.</para>

    <para>A URL like
    <uri>https://www.example.com/index.php?option=com_whatever&amp;format=json</uri>
    — despite the two problems already mentioned above — would still populate
    <varname>$document</varname> with a <classname>JSONDocument</classname>
    object. However, <classname>JSONDocument</classname> does not have an
    <methodname>addScript</methodname> method. Therefore this plugin causes a
    PHP fatal error right away. Whoops!</para>

    <para>The correct way to do that is called “feature detection”:</para>

    <programlisting language="php">$document = \Joomla\CMS\Factory::getApplication()-&gt;getDocument();

if (!($document instanceof \Joomla\CMS\Document\HtmlDocument))
{
    return;
}</programlisting>

    <para>If the document returned by our application is not an
    <classname>HTMLDocument</classname> we do not try to do anything else.
    Simple, isn't it?</para>

    <bridgehead>There is more to Joomla than the frontend and
    backend</bridgehead>

    <para>Now let's get to the biggest bug of them all: assuming that Joomla
    consists entirely of the frontend (site) and backend (administrator)
    application. This has not been true since Joomla 1.6, released in
    <emphasis>2010</emphasis>. When I first wrote this section in 2022 it was
    already <emphasis>12 years</emphasis> this assumption has been wrong and I
    would still see plugins making it and breaking Joomla sites.</para>

    <para>Not to put too fine a point on this, this line is completely
    wrong:</para>

    <programlisting language="php">if (\Joomla\CMS\Factory::getApplication()-&gt;isClient('administrator')) return;</programlisting>

    <para>Clearly, the developer wanted their code to mean “if this is not the
    frontend of the site don't do anything”. Instead, what they actually wrote
    is “if this is the backend of the site — therefore this is the frontend of
    the site <emphasis>or the api application, or the console application, or
    any custom application which extends from Joomla's
    <classname>WebApplication</classname> class</emphasis> — don't do
    anything”. Whoops!</para>

    <para>As we have already mentioned, Joomla 4 has a number of applications
    shipped with it:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">installation</emphasis>. This is the web
        installer when you build a new site. Third party code, like our
        counterexample system plugin, does not load in it and does not concern
        third party developers. It lives in the
        <filename>installation</filename> folder of your site. It's been
        around since Joomla 1.0.</para>

        <note>
          <para>If an <filename>installation</filename> folder is present
          Joomla will redirect to it if you try to access any of its other
          web-based applications. This happens very early in the
          <filename>includes/framework.php</filename> file which is one of the
          first things loaded by <filename>includes/app.php</filename>, after
          loading <filename>includes/defines.php</filename> and making sure
          the <filename>libraries/vendor</filename> folder exists.</para>

          <para>This automatic redirection does not happen when
          <constant>\Joomla\CMS\Version::DEV_STATUS</constant> is anything
          other than <parameter>stable</parameter>, i.e. in
          <parameter>alpha</parameter>, <parameter>beta</parameter>,
          <parameter>rc</parameter> (Release candidate) releases and
          <parameter>dev</parameter> (development) builds from the Joomla Git
          repository sources.</para>
        </note>
      </listitem>

      <listitem>
        <para><emphasis role="bold">site</emphasis>. The frontend of the site,
        accessed through the <filename>index.php</filename> file in your
        site's root. It's been around since Joomla 1.0.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">administrator</emphasis>. The backend of
        the site, accessed through
        <filename>administrator/index.php</filename>. It lives in the
        <filename>administrator</filename> folder of your site. It's been
        around since Joomla 1.0.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">api</emphasis>. The JSON API application,
        accessed through <filename>api/index.php</filename>. It lives in the
        <filename>api</filename> folder of your Joomla site. Introduced in
        Joomla 4.0.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">cli</emphasis>. The
        <filename>cli/joomla.php</filename> command line application.
        Introduced in Joomla 4.0.</para>
      </listitem>
    </itemizedlist>

    <para>Further to that, applications other than site and administrator have
    existing since Joomla 1.5.</para>

    <para>From Joomla 1.5 onwards it's been possible to create your own custom
    application by extending <classname>JApplicationWeb</classname>. These
    custom application do load system plugins by default. They were used to
    create custom entry points for callbacks, e.g. in payment plugins for
    e-commerce components. They are no longer used as the reason for their
    existence has been made a moot point since the advent of
    <code>com_ajax</code> in Joomla 2.5.</para>

    <para>From Joomla 1.6 and up until Joomla 5.4 it's possible for developers
    to create custom CLI applications by extending
    <classname>JApplicationCli</classname>. These applications do not load
    system plugins by default so they are unlikely to have broken. Unlikely
    does not mean impossible, though; it's possible that a CLI application may
    have a need to load plugins such as <filename>system</filename>,
    <filename>content</filename>, <filename>privacy</filename> etc.</para>

    <para>This is why despite the fact that this has been an issue since the
    dawn of Joomla 1.5 in 2007 plugin developers may have not bumped into this
    until Joomla 4 was released.</para>

    <para>The correct way to do this is, of course, to check explicitly for
    the application you want to run under:</para>

    <programlisting language="php">if (!\Joomla\CMS\Factory::getApplication()-&gt;isClient('<emphasis
        role="bold">site</emphasis>')) return;</programlisting>

    <bridgehead>Do not load static resources directly and/or from your
    plugin's folder</bridgehead>

    <para>This is a bonus round and not a bug which will break sites
    <emphasis>today</emphasis>, but it will break sites come Joomla 6.0 and a
    mild security concern. It also reminds us that plugins, like all other
    Joomla extension types, should be <link
    linkend="concepts-webassetmanager">using the
    WebAssetManager</link>.</para>

    <para>The developer of the extension chose to load their static JavaScript
    file using the deprecated <methodname>addScript()</methodname> method of
    the document and located the file in the plugin's folder structure. This
    is a two in one issue.</para>

    <para>First of all, ever since Joomla 1.5 (released in 2007 — <emphasis>15
    years</emphasis> before I first wrote this section in 2022) Joomla
    introduced the <filename>media</filename> folder where extensions are
    expected to place all publicly available static files, be they static
    files shipped with the extension or user-generated content managed outside
    Joomla's Media Manager.</para>

    <para>The developer of the plugin should have placed their JavaScript file
    in the <filename>media/plg_system_foobar/js</filename> folder using the
    following section in their plugin's XML manifest:</para>

    <programlisting language="xml">&lt;media folder="media" destination="plg_system_foobar"&gt;
    &lt;folder&gt;js&lt;/folder&gt;
    &lt;file&gt;joomla.asset.json&lt;/file&gt;
&lt;/media&gt;</programlisting>

    <para>(We'll see what the joomla.asset.json file is in a moment)</para>

    <para>It is a bad security practice mixing executable backend code
    (<filename>.php</filename> files) with frontend executable code
    (<filename>.js</filename>, <filename>.es6</filename> etc) files and static
    media files (CSS, images, videos, ...).</para>

    <para>Joomla is moving towards placing all frontend (web browser)
    accessible stuff into the media folder — even for templates, as of Joomla
    4.1 — and will most likely start applying security controls to prevent web
    access to the plugin, component, module etc folders. <emphasis
    role="bold">You have been warned</emphasis>. In fact, you were being
    warned since 2007 but nobody was listening, so let's see how many
    developers will come screaming bloody murder when these access controls
    are enforced about <emphasis>20 years</emphasis> after the preferred
    alternative was introduced in Joomla 1.5.0. Ahem. forgive me, I
    digressed.</para>

    <para>The next issue is that HTMLDocument's
    <methodname>addScript()</methodname> method has been deprecated. Joomla 4
    has moved into using asset dependencies and a <link
    linkend="concepts-webassetmanager">Web Asset Manager</link> to, well,
    manage the asset dependencies.</para>

    <para>Assets and their dependencies are declared in the
    <filename>joomla.asset.json</filename> file located in the extension's
    subdirectory under the <filename>media</filename> directory. So, the
    developer should have shipped a file
    <filename>media/plg_system_foobar/joomla.asset.json</filename> with the
    following contents:</para>

    <programlisting language="json">{
    "$schema": "https://developer.joomla.org/schemas/json-schema/web_assets.json",
    "name": "plg_system_foobar",
    "version": "1.0.0",
    "description": "Foobar plugin",
    "license": "GPL-3.0-or-later",
    "assets": [
        {
            "name": "plg_system_foobar.foobar",
            "description": "Foobar JavaScript",
            "type": "script",
            "uri": "plg_system_foobar/foobar.js",
            "dependencies": [
                "core"
            ],
            "attributes": {
                "defer": true
            }
        }
    ]
}</programlisting>

    <para>This allows the developer to tell Joomla to add their script using
    this very simple piece of code:</para>

    <programlisting language="php">$document-&gt;getWebAssetManager()-&gt;useScript('plg_system_foobar.foobar');</programlisting>

    <para>Here's the kicker. <emphasis>This is safe even if you don't check
    the Document object type</emphasis>. Yeah, if <varname>$document</varname>
    is a <classname>JSONDocument</classname> which does not have a concept of
    web assets this code would still work. Joomla defines the Web Asset
    Manager for all document types, even those which can't possibly use it.
    It's the page renderer which will make use of the dependencies, if they
    are supported. I know, right?! It's actually an amazingly good feature!
    That said, it's still a good idea to check the document type the way I've
    told you to avoid doing pointless work, or introducing future bugs.</para>

    <bridgehead>Putting it all together</bridgehead>

    <para>Let's put everything we learned together. The tiny plugin barely
    grew by a couple of lines and it no longer breaks the sites it is
    installed in. The changes are in bold type:</para>

    <programlisting language="php">class PlgSystemFoobar extends \Joomla\CMS\Plugin\CMSPlugin
{
    public function <emphasis role="bold">onAfterDispatch</emphasis>()
    {
        if (!\Joomla\CMS\Factory::getApplication()-&gt;isClient('<emphasis
        role="bold">site</emphasis>')) return;

        $document = \Joomla\CMS\Factory<emphasis role="bold">::getApplication()-&gt;getDocument();</emphasis>

        <emphasis role="bold">if (!($document instanceof \Joomla\CMS\Document\HtmlDocument))
        {
            return;
        }

        $document-&gt;getWebAssetManager()-&gt;useScript('plg_system_foobar.foobar');</emphasis>
    }
}</programlisting>

    <para>It's still short. It's still readable. It's (mostly) future-proof —
    well, it's still using the legacy plugin structure but I was trying to
    draw your attention to the problems, not divert your attention to the
    plumbing covered in previous sections of this book.</para>
  </section>

  <section xml:id="plg-concrete-events">
    <title>Generic versus Concrete events</title>

    <para/>
  </section>
</chapter>
